import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.skkuse.team1.socialhub.StarterVerticle;
import com.skkuse.team1.socialhub.jdbc.impl.UserJDBC;
import com.skkuse.team1.socialhub.model.Activity;
import com.skkuse.team1.socialhub.model.User;
import com.skkuse.team1.socialhub.requests.RequestActivityCommit;
import com.skkuse.team1.socialhub.requests.RequestChangePassword;
import com.skkuse.team1.socialhub.requests.RequestLogin;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.client.WebClient;
import io.vertx.ext.web.client.WebClientOptions;
import io.vertx.ext.web.client.WebClientSession;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.function.BiFunction;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(VertxExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Testcontainers
public class MainTest {

    record HelperLoggedIn(WebClientSession session, User user) {}
    List<HelperLoggedIn> loggedInSessionList = new ArrayList<>();

    @BeforeAll
    public void init(Vertx vertx, VertxTestContext tc) throws Exception {
        System.setProperty("DB_NAME", "test_db");
        System.setProperty("DB_USER", "sample");
        System.setProperty("DB_PASSWORD", "sample");
        // Start postgresql container. Ryuk Container will kill this container after test completion.
        PostgreSQLContainer container = new PostgreSQLContainer("postgres:12")
                .withDatabaseName(System.getProperty("DB_NAME"))
                .withUsername(System.getProperty("DB_USER"))
                .withPassword(System.getProperty("DB_PASSWORD"));
        container.start();
        // Set properties which are generated by the container.
        System.setProperty("DB_PORT", container.getMappedPort(5432).toString());
        System.setProperty("DB_HOST", container.getHost());
        vertx.deployVerticle(StarterVerticle.class.getName()).onComplete(tc.succeedingThenComplete());
    }

    @JsonIgnoreProperties(value = { "ok" })
    class TestRequestLogin extends RequestLogin {

        private boolean isOk;

        public TestRequestLogin(String login, String password, boolean isOk) {
            super(login, password);
            this.isOk = isOk;
        }

        public boolean isOk() {
            return isOk;
        }

        @Override
        public String toString() {
            return "As %s Valid: %s".formatted(getLogin(), isOk);
        }
    }

    public Stream<User> SOURCE_USERS() {
        return Stream.of(
                new User("user0", "sample0", 0, "Dog name"),
                new User("user1", "sample1", 0, "Dog name 1"),
                new User("user2", "sample2", 0, "Dog name 2"),
                new User("user3", "sample3", 0, "Dog name 3")
        );
    }

    public Stream<TestRequestLogin> SOURCE_LOGIN() {
        return Stream.of(
                new TestRequestLogin("user0", "sample0", true),
                new TestRequestLogin("user0", "sample1", false),
                new TestRequestLogin("user1", "sample1", true),
                new TestRequestLogin("user2", "sample2", true),
                new TestRequestLogin("user3", "sample3", true)
        );
    }

    @ParameterizedTest()
    @MethodSource("SOURCE_USERS")
    @DisplayName("Create users")
    @Order(1)
    public void createUser(User preUser, Vertx vertx, VertxTestContext tc) {
        UserJDBC.instance().create(preUser).onComplete(tc.succeeding(user -> tc.verify(() -> {
            assertEquals(preUser.getUsername(), user.getUsername());
            assertNull(user.getPassword());
            assertNull(user.getIdSecurityQuestion());
            assertNull(user.getSecurityAnswer());
            assertNotNull(user.getId());
            tc.completeNow();
        })));
    }

    @ParameterizedTest(name = "{0}")
    @MethodSource("SOURCE_LOGIN")
    @Order(2)
    @DisplayName("Login")
    public void loginTest(TestRequestLogin requestLogin, Vertx vertx, VertxTestContext tc) {
        WebClientSession session = WebClientSession.create(WebClient.create(vertx, new WebClientOptions().setDefaultPort(8080).setDefaultHost("localhost")));
        session.addHeader(HttpHeaders.CONTENT_TYPE.toString(), "application/json;charset=utf-8");
        session.post("/api/public/v1/users/login")
                .sendJsonObject(JsonObject.mapFrom(requestLogin))
                .compose(response -> {
                    try {
                        if(!requestLogin.isOk) {
                            assertNotEquals(200, response.statusCode());
                            return Future.succeededFuture();
                        }else{
                            assertEquals(200, response.statusCode());
                            JsonObject body = response.bodyAsJsonObject();
                            assertNotNull(body.getString("access_token"));
                            session.addHeader(HttpHeaders.AUTHORIZATION.toString(), "%s %s".formatted(body.getString("token_type"), body.getString("access_token")));
                            // Request information about current user
                            return session.get("/api/protected/v1/users/me").send().compose(responseCurrentInfo -> {
                                try {
                                    assertEquals(200, responseCurrentInfo.statusCode());
                                    loggedInSessionList.add(new HelperLoggedIn(session, responseCurrentInfo.bodyAsJsonObject().mapTo(User.class)));
                                    return Future.succeededFuture();
                                }catch (Throwable ex){
                                    return Future.failedFuture(ex);
                                }
                            });
                        }
                    }catch (Throwable ex) {
                        return Future.failedFuture(ex);
                    }
                })
                .onComplete(tc.succeedingThenComplete());
    }

    @Test
    @Order(3)
    @DisplayName("Change password")
    public void changePasswordTest(Vertx vertx, VertxTestContext tc) {
        // Login
        @SuppressWarnings("OptionalGetWithoutIsPresent")
        RequestLogin requestLogin = SOURCE_LOGIN().filter(TestRequestLogin::isOk).findFirst().get();
        RequestChangePassword requestChangePassword = new RequestChangePassword("new-password", requestLogin.getPassword());
        WebClientSession session = WebClientSession.create(WebClient.create(vertx, new WebClientOptions().setDefaultPort(8080).setDefaultHost("localhost")));
        session.addHeader(HttpHeaders.CONTENT_TYPE.toString(), "application/json;charset=utf-8");
        session.post("/api/protected/v1/users/change-password")
                .sendBuffer(Buffer.buffer(JsonObject.mapFrom(requestChangePassword).encode()))
                .compose(response -> {
                    try {
                        // Unauthorized
                        assertNotEquals(200, response.statusCode());
                        return session.post("/api/public/v1/users/login")
                                .sendJsonObject(JsonObject.mapFrom(requestLogin));
                    } catch (Throwable ex) {
                        return Future.failedFuture(ex);
                    }
                }).compose(response -> {
                    try {
                        // Authorize
                        assertEquals(200, response.statusCode());
                        JsonObject authorizationObject = response.bodyAsJsonObject();
                        // Set JWT token
                        session.addHeader(HttpHeaders.AUTHORIZATION, "%s %s".formatted(authorizationObject.getString("token_type"), authorizationObject.getString("access_token")));
                        return session.post("/api/protected/v1/users/change-password")
                                .sendJsonObject(JsonObject.mapFrom(requestChangePassword));
                    } catch (Throwable ex) {
                        return Future.failedFuture(ex);
                    }
                }).compose(response -> {
                    try {
                        assertEquals(200, response.statusCode());
                        // Login with new Password
                        requestLogin.setPassword(requestChangePassword.getPassword());
                        return session.post("/api/public/v1/users/login")
                                .sendJsonObject(JsonObject.mapFrom(requestLogin));
                    }catch (Throwable ex) {
                        return Future.failedFuture(ex);
                    }
                }).onComplete(tc.succeeding(response -> tc.verify(() -> {
                    assertEquals(200, response.statusCode());
                    tc.completeNow();
                })));
    }

    Activity activity;
    HelperLoggedIn creatorSession, participantSession, notParticipantSession;
    @Test
    @Order(4)
    public void createActivityTest(Vertx vertx, VertxTestContext tc) {
        creatorSession = loggedInSessionList.get(0);
        participantSession = loggedInSessionList.get(1);
        notParticipantSession = loggedInSessionList.get(2);
        RequestActivityCommit request = new RequestActivityCommit(
                "sample",
                "sample activity",
                "sample location",
                LocalDateTime.now(),
                loggedInSessionList.get(1).user.getId()
        );
        BiFunction<HelperLoggedIn, Boolean, Future<Void>> checkerFunc = (helper, isOk) -> {
            return helper.session.get("/api/protected/v1/activities/")
                    .send()
                    .compose(response -> {
                        try {
                            assertEquals(200, response.statusCode());
                            assertEquals(isOk ? 1 : 0, response.bodyAsJsonArray().size());
                            return Future.succeededFuture();
                        }catch (Throwable ex) {
                            return Future.failedFuture(ex);
                        }
                    });
        };
        creatorSession.session.post("/api/protected/v1/activities/")
                .sendJsonObject(JsonObject.mapFrom(request))
                .compose(response -> {
                    try {
                        assertEquals(200, response.statusCode());
                        activity = response.bodyAsJsonArray().getJsonObject(0).mapTo(Activity.class);
                        // Only participants and creator allowed to see activity
                        return CompositeFuture.all(
                                checkerFunc.apply(creatorSession, true),
                                checkerFunc.apply(participantSession, true),
                                checkerFunc.apply(notParticipantSession, false)
                        );
                    }catch (Throwable ex) {
                        return Future.failedFuture(ex);
                    }
                }).onComplete(tc.succeedingThenComplete());
    }

    @Test
    @Order(5)
    public void checkActivityAccessTest(Vertx vertx, VertxTestContext tc) {
        // Participant not allowed to delete or edit activity
        participantSession.session.delete("/api/protected/v1/activities/%s".formatted(activity.getId()))
                .send().compose(response -> {
                    try{
                        assertNotEquals(200, response.statusCode());
                        return creatorSession.session.delete("/api/protected/v1/activities/%s".formatted(activity.getId())).send();
                    }catch (Throwable ex) {
                        return Future.failedFuture(ex);
                    }
                }).onComplete(tc.succeeding(response -> tc.verify(() -> {
                    assertEquals(200, response.statusCode());
                    tc.completeNow();
                })));
    }
}
